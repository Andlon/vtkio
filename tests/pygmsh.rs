//! This test module tests against simple files generated by the pygmsh package.

use nom::IResult;
use vtkio::model::*;
use vtkio::parser::*;
use vtkio::writer::*;
use vtkio::Error;

macro_rules! test_b {
    ($fn:ident ($in:expr, $($args:expr),*) => $out:expr) => {
        assert_eq!($fn($in, $($args),*), IResult::Done("".as_bytes(), $out.clone()));
    };
    ($fn:ident ($in:expr) => $out:expr) => {
        assert_eq!($fn($in), IResult::Done("".as_bytes(), $out.clone()));
    };
}

macro_rules! test_ignore_rem {
    ($fn:ident ($in:expr, $($args:expr),*) => $out:expr) => {
        {
            let result = $fn($in, $($args),*);
            assert!(result.is_done());
            assert_eq!(result.unwrap().1, $out.clone());
        }
    };
    ($fn:ident ($in:expr) => $out:expr) => {
        {
            let result = $fn($in);
            assert!(result.is_done());
            assert_eq!(result.unwrap().1, $out.clone());
        }
    };
}

type Result = std::result::Result<(), Error>;

// Helper functions to convert between endianness.

fn ne(vtk: &Vtk) -> Vtk {
    Vtk {
        byte_order: ByteOrder::native(),
        ..vtk.clone()
    }
}

fn le(vtk: &Vtk) -> Vtk {
    Vtk {
        byte_order: ByteOrder::LittleEndian,
        ..vtk.clone()
    }
}

fn make_test_file() -> Vtk {
    Vtk {
        version: Version::new((5, 1)),
        byte_order: ByteOrder::BigEndian,
        title: String::from("written by meshio v5.3.0"),
        file_path: None,
        data: DataSet::inline(UnstructuredGridPiece {
            points: vec![
                0.0f64,
                0.0,
                0.0,
                1.0,
                -0.2,
                0.0,
                1.1,
                1.2,
                0.0,
                0.1,
                0.7,
                0.0,
                0.3333333333325021,
                -0.06666666666650042,
                0.0,
                0.6666666666657866,
                -0.1333333333331573,
                0.0,
                1.0249999999999424,
                0.14999999999919245,
                0.0,
                1.0499999999998704,
                0.4999999999981836,
                0.0,
                1.074999999999934,
                0.8499999999990746,
                0.0,
                0.766666666667985,
                1.0333333333339925,
                0.0,
                0.433333333334733,
                0.8666666666673664,
                0.0,
                0.050000000000122564,
                0.3500000000008579,
                0.0,
                0.7444729167676052,
                0.3524793413776178,
                0.0,
                0.3781088913238718,
                0.4816987298113132,
                0.0,
                0.7412636346823331,
                0.6806963451979247,
                0.0,
                0.5070791452210437,
                0.16277273408010906,
                0.0,
                0.253704273975508,
                0.18556095944515594,
                0.0,
                0.7797139636550688,
                0.08823831456107314,
                0.0,
            ]
            .into(),
            cells: Cells {
                cell_verts: VertexNumbers::XML {
                    offsets: vec![
                        0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 27, 30, 33, 36, 39, 42, 45,
                        48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 91, 92, 93, 94,
                    ],
                    connectivity: vec![
                        0, 4, 4, 5, 5, 1, 1, 6, 6, 7, 7, 8, 8, 2, 2, 9, 9, 10, 10, 3, 3, 11, 11, 0,
                        10, 13, 14, 13, 12, 14, 10, 3, 13, 8, 2, 9, 4, 5, 15, 9, 10, 14, 3, 11, 13,
                        6, 7, 12, 8, 9, 14, 7, 8, 14, 12, 7, 14, 15, 5, 17, 5, 1, 17, 1, 6, 17, 12,
                        13, 15, 13, 11, 16, 15, 13, 16, 11, 0, 16, 0, 4, 16, 6, 12, 17, 12, 15, 17,
                        4, 15, 16, 0, 1, 2, 3,
                    ],
                },
                types: vec![
                    vec![CellType::Line; 12],
                    vec![CellType::Triangle; 22],
                    vec![CellType::Vertex; 4],
                ]
                .into_iter()
                .flatten()
                .collect::<Vec<CellType>>(),
            },
            data: Attributes {
                point: vec![],
                cell: vec![],
            },
        }),
    }
}

#[test]
fn legacy_ascii() -> Result {
    let input = include_str!("../assets/pygmsh/ascii.vtk").as_bytes();
    let out1 = make_test_file();
    assert!(parse_be(input).is_done());
    test_ignore_rem!(parse_be(input) => out1);
    let mut outtest = String::new();
    outtest.write_vtk_ne(out1.clone())?;
    println!("{}", outtest);
    test_b!(parse_ne(String::new().write_vtk_ne(out1.clone())?.as_bytes()) => ne(&out1));
    test_b!(parse_ne(Vec::<u8>::new().write_vtk_ne(out1.clone())?) => ne(&out1));
    test_b!(parse_le(Vec::<u8>::new().write_vtk_le(out1.clone())?) => le(&out1));
    test_b!(parse_be(Vec::<u8>::new().write_vtk_be(out1.clone())?) => out1);
    Ok(())
}

#[test]
fn legacy_binary() -> Result {
    let input = include_bytes!("../assets/pygmsh/binary.vtk");
    let out1 = make_test_file();
    assert!(parse_be(input).is_done());
    test_ignore_rem!(parse_be(input) => out1);
    let mut outtest = String::new();
    outtest.write_vtk_ne(out1.clone())?;
    println!("{}", outtest);
    test_b!(parse_ne(String::new().write_vtk_ne(out1.clone())?.as_bytes()) => ne(&out1));
    test_b!(parse_ne(Vec::<u8>::new().write_vtk_ne(out1.clone())?) => ne(&out1));
    test_b!(parse_le(Vec::<u8>::new().write_vtk_le(out1.clone())?) => le(&out1));
    test_b!(parse_be(Vec::<u8>::new().write_vtk_be(out1.clone())?) => out1);
    Ok(())
}

#[test]
#[ignore]
fn xml_ascii() -> Result {
    let mut vtu = Vtk::import("./assets/pygmsh/ascii.vtu")?;
    vtu.file_path = None; // Reset file path to satisfy comparison
    assert_eq!(vtu, make_test_file());
    Ok(())
}
